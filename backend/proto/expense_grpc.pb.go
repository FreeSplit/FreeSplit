// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.2.0
// - protoc             v6.32.0
// source: proto/expense.proto

package proto

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// ExpenseServiceClient is the client API for ExpenseService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExpenseServiceClient interface {
	GetExpensesByGroup(ctx context.Context, in *GetExpensesByGroupRequest, opts ...grpc.CallOption) (*GetExpensesByGroupResponse, error)
	GetSplitsByParticipant(ctx context.Context, in *GetSplitsByParticipantRequest, opts ...grpc.CallOption) (*GetSplitsByParticipantResponse, error)
	GetExpenseWithSplits(ctx context.Context, in *GetExpenseWithSplitsRequest, opts ...grpc.CallOption) (*GetExpenseWithSplitsResponse, error)
	CreateExpense(ctx context.Context, in *CreateExpenseRequest, opts ...grpc.CallOption) (*CreateExpenseResponse, error)
	UpdateExpense(ctx context.Context, in *UpdateExpenseRequest, opts ...grpc.CallOption) (*UpdateExpenseResponse, error)
	DeleteExpense(ctx context.Context, in *DeleteExpenseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type expenseServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewExpenseServiceClient(cc grpc.ClientConnInterface) ExpenseServiceClient {
	return &expenseServiceClient{cc}
}

func (c *expenseServiceClient) GetExpensesByGroup(ctx context.Context, in *GetExpensesByGroupRequest, opts ...grpc.CallOption) (*GetExpensesByGroupResponse, error) {
	out := new(GetExpensesByGroupResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/GetExpensesByGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseServiceClient) GetSplitsByParticipant(ctx context.Context, in *GetSplitsByParticipantRequest, opts ...grpc.CallOption) (*GetSplitsByParticipantResponse, error) {
	out := new(GetSplitsByParticipantResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/GetSplitsByParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseServiceClient) GetExpenseWithSplits(ctx context.Context, in *GetExpenseWithSplitsRequest, opts ...grpc.CallOption) (*GetExpenseWithSplitsResponse, error) {
	out := new(GetExpenseWithSplitsResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/GetExpenseWithSplits", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseServiceClient) CreateExpense(ctx context.Context, in *CreateExpenseRequest, opts ...grpc.CallOption) (*CreateExpenseResponse, error) {
	out := new(CreateExpenseResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/CreateExpense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseServiceClient) UpdateExpense(ctx context.Context, in *UpdateExpenseRequest, opts ...grpc.CallOption) (*UpdateExpenseResponse, error) {
	out := new(UpdateExpenseResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/UpdateExpense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *expenseServiceClient) DeleteExpense(ctx context.Context, in *DeleteExpenseRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/freesplit.ExpenseService/DeleteExpense", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExpenseServiceServer is the server API for ExpenseService service.
// All implementations must embed UnimplementedExpenseServiceServer
// for forward compatibility
type ExpenseServiceServer interface {
	GetExpensesByGroup(context.Context, *GetExpensesByGroupRequest) (*GetExpensesByGroupResponse, error)
	GetSplitsByParticipant(context.Context, *GetSplitsByParticipantRequest) (*GetSplitsByParticipantResponse, error)
	GetExpenseWithSplits(context.Context, *GetExpenseWithSplitsRequest) (*GetExpenseWithSplitsResponse, error)
	CreateExpense(context.Context, *CreateExpenseRequest) (*CreateExpenseResponse, error)
	UpdateExpense(context.Context, *UpdateExpenseRequest) (*UpdateExpenseResponse, error)
	DeleteExpense(context.Context, *DeleteExpenseRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedExpenseServiceServer()
}

// UnimplementedExpenseServiceServer must be embedded to have forward compatible implementations.
type UnimplementedExpenseServiceServer struct {
}

func (UnimplementedExpenseServiceServer) GetExpensesByGroup(context.Context, *GetExpensesByGroupRequest) (*GetExpensesByGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExpensesByGroup not implemented")
}
func (UnimplementedExpenseServiceServer) GetSplitsByParticipant(context.Context, *GetSplitsByParticipantRequest) (*GetSplitsByParticipantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSplitsByParticipant not implemented")
}
func (UnimplementedExpenseServiceServer) GetExpenseWithSplits(context.Context, *GetExpenseWithSplitsRequest) (*GetExpenseWithSplitsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetExpenseWithSplits not implemented")
}
func (UnimplementedExpenseServiceServer) CreateExpense(context.Context, *CreateExpenseRequest) (*CreateExpenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateExpense not implemented")
}
func (UnimplementedExpenseServiceServer) UpdateExpense(context.Context, *UpdateExpenseRequest) (*UpdateExpenseResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateExpense not implemented")
}
func (UnimplementedExpenseServiceServer) DeleteExpense(context.Context, *DeleteExpenseRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteExpense not implemented")
}
func (UnimplementedExpenseServiceServer) mustEmbedUnimplementedExpenseServiceServer() {}

// UnsafeExpenseServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExpenseServiceServer will
// result in compilation errors.
type UnsafeExpenseServiceServer interface {
	mustEmbedUnimplementedExpenseServiceServer()
}

func RegisterExpenseServiceServer(s grpc.ServiceRegistrar, srv ExpenseServiceServer) {
	s.RegisterService(&ExpenseService_ServiceDesc, srv)
}

func _ExpenseService_GetExpensesByGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExpensesByGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).GetExpensesByGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/GetExpensesByGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).GetExpensesByGroup(ctx, req.(*GetExpensesByGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseService_GetSplitsByParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSplitsByParticipantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).GetSplitsByParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/GetSplitsByParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).GetSplitsByParticipant(ctx, req.(*GetSplitsByParticipantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseService_GetExpenseWithSplits_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExpenseWithSplitsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).GetExpenseWithSplits(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/GetExpenseWithSplits",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).GetExpenseWithSplits(ctx, req.(*GetExpenseWithSplitsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseService_CreateExpense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateExpenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).CreateExpense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/CreateExpense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).CreateExpense(ctx, req.(*CreateExpenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseService_UpdateExpense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateExpenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).UpdateExpense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/UpdateExpense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).UpdateExpense(ctx, req.(*UpdateExpenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExpenseService_DeleteExpense_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExpenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExpenseServiceServer).DeleteExpense(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ExpenseService/DeleteExpense",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExpenseServiceServer).DeleteExpense(ctx, req.(*DeleteExpenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExpenseService_ServiceDesc is the grpc.ServiceDesc for ExpenseService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExpenseService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "freesplit.ExpenseService",
	HandlerType: (*ExpenseServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetExpensesByGroup",
			Handler:    _ExpenseService_GetExpensesByGroup_Handler,
		},
		{
			MethodName: "GetSplitsByParticipant",
			Handler:    _ExpenseService_GetSplitsByParticipant_Handler,
		},
		{
			MethodName: "GetExpenseWithSplits",
			Handler:    _ExpenseService_GetExpenseWithSplits_Handler,
		},
		{
			MethodName: "CreateExpense",
			Handler:    _ExpenseService_CreateExpense_Handler,
		},
		{
			MethodName: "UpdateExpense",
			Handler:    _ExpenseService_UpdateExpense_Handler,
		},
		{
			MethodName: "DeleteExpense",
			Handler:    _ExpenseService_DeleteExpense_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/expense.proto",
}

// GroupServiceClient is the client API for GroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GroupServiceClient interface {
	GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error)
	CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error)
	UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error)
}

type groupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewGroupServiceClient(cc grpc.ClientConnInterface) GroupServiceClient {
	return &groupServiceClient{cc}
}

func (c *groupServiceClient) GetGroup(ctx context.Context, in *GetGroupRequest, opts ...grpc.CallOption) (*GetGroupResponse, error) {
	out := new(GetGroupResponse)
	err := c.cc.Invoke(ctx, "/freesplit.GroupService/GetGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) CreateGroup(ctx context.Context, in *CreateGroupRequest, opts ...grpc.CallOption) (*CreateGroupResponse, error) {
	out := new(CreateGroupResponse)
	err := c.cc.Invoke(ctx, "/freesplit.GroupService/CreateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *groupServiceClient) UpdateGroup(ctx context.Context, in *UpdateGroupRequest, opts ...grpc.CallOption) (*UpdateGroupResponse, error) {
	out := new(UpdateGroupResponse)
	err := c.cc.Invoke(ctx, "/freesplit.GroupService/UpdateGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GroupServiceServer is the server API for GroupService service.
// All implementations must embed UnimplementedGroupServiceServer
// for forward compatibility
type GroupServiceServer interface {
	GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error)
	CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error)
	UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error)
	mustEmbedUnimplementedGroupServiceServer()
}

// UnimplementedGroupServiceServer must be embedded to have forward compatible implementations.
type UnimplementedGroupServiceServer struct {
}

func (UnimplementedGroupServiceServer) GetGroup(context.Context, *GetGroupRequest) (*GetGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGroup not implemented")
}
func (UnimplementedGroupServiceServer) CreateGroup(context.Context, *CreateGroupRequest) (*CreateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateGroup not implemented")
}
func (UnimplementedGroupServiceServer) UpdateGroup(context.Context, *UpdateGroupRequest) (*UpdateGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateGroup not implemented")
}
func (UnimplementedGroupServiceServer) mustEmbedUnimplementedGroupServiceServer() {}

// UnsafeGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GroupServiceServer will
// result in compilation errors.
type UnsafeGroupServiceServer interface {
	mustEmbedUnimplementedGroupServiceServer()
}

func RegisterGroupServiceServer(s grpc.ServiceRegistrar, srv GroupServiceServer) {
	s.RegisterService(&GroupService_ServiceDesc, srv)
}

func _GroupService_GetGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).GetGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.GroupService/GetGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).GetGroup(ctx, req.(*GetGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_CreateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).CreateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.GroupService/CreateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).CreateGroup(ctx, req.(*CreateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GroupService_UpdateGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GroupServiceServer).UpdateGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.GroupService/UpdateGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GroupServiceServer).UpdateGroup(ctx, req.(*UpdateGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GroupService_ServiceDesc is the grpc.ServiceDesc for GroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "freesplit.GroupService",
	HandlerType: (*GroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetGroup",
			Handler:    _GroupService_GetGroup_Handler,
		},
		{
			MethodName: "CreateGroup",
			Handler:    _GroupService_CreateGroup_Handler,
		},
		{
			MethodName: "UpdateGroup",
			Handler:    _GroupService_UpdateGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/expense.proto",
}

// ParticipantServiceClient is the client API for ParticipantService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ParticipantServiceClient interface {
	AddParticipant(ctx context.Context, in *AddParticipantRequest, opts ...grpc.CallOption) (*AddParticipantResponse, error)
	UpdateParticipant(ctx context.Context, in *UpdateParticipantRequest, opts ...grpc.CallOption) (*UpdateParticipantResponse, error)
	DeleteParticipant(ctx context.Context, in *DeleteParticipantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
}

type participantServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewParticipantServiceClient(cc grpc.ClientConnInterface) ParticipantServiceClient {
	return &participantServiceClient{cc}
}

func (c *participantServiceClient) AddParticipant(ctx context.Context, in *AddParticipantRequest, opts ...grpc.CallOption) (*AddParticipantResponse, error) {
	out := new(AddParticipantResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ParticipantService/AddParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantServiceClient) UpdateParticipant(ctx context.Context, in *UpdateParticipantRequest, opts ...grpc.CallOption) (*UpdateParticipantResponse, error) {
	out := new(UpdateParticipantResponse)
	err := c.cc.Invoke(ctx, "/freesplit.ParticipantService/UpdateParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *participantServiceClient) DeleteParticipant(ctx context.Context, in *DeleteParticipantRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/freesplit.ParticipantService/DeleteParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ParticipantServiceServer is the server API for ParticipantService service.
// All implementations must embed UnimplementedParticipantServiceServer
// for forward compatibility
type ParticipantServiceServer interface {
	AddParticipant(context.Context, *AddParticipantRequest) (*AddParticipantResponse, error)
	UpdateParticipant(context.Context, *UpdateParticipantRequest) (*UpdateParticipantResponse, error)
	DeleteParticipant(context.Context, *DeleteParticipantRequest) (*emptypb.Empty, error)
	mustEmbedUnimplementedParticipantServiceServer()
}

// UnimplementedParticipantServiceServer must be embedded to have forward compatible implementations.
type UnimplementedParticipantServiceServer struct {
}

func (UnimplementedParticipantServiceServer) AddParticipant(context.Context, *AddParticipantRequest) (*AddParticipantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipant not implemented")
}
func (UnimplementedParticipantServiceServer) UpdateParticipant(context.Context, *UpdateParticipantRequest) (*UpdateParticipantResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateParticipant not implemented")
}
func (UnimplementedParticipantServiceServer) DeleteParticipant(context.Context, *DeleteParticipantRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteParticipant not implemented")
}
func (UnimplementedParticipantServiceServer) mustEmbedUnimplementedParticipantServiceServer() {}

// UnsafeParticipantServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ParticipantServiceServer will
// result in compilation errors.
type UnsafeParticipantServiceServer interface {
	mustEmbedUnimplementedParticipantServiceServer()
}

func RegisterParticipantServiceServer(s grpc.ServiceRegistrar, srv ParticipantServiceServer) {
	s.RegisterService(&ParticipantService_ServiceDesc, srv)
}

func _ParticipantService_AddParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddParticipantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantServiceServer).AddParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ParticipantService/AddParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantServiceServer).AddParticipant(ctx, req.(*AddParticipantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantService_UpdateParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateParticipantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantServiceServer).UpdateParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ParticipantService/UpdateParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantServiceServer).UpdateParticipant(ctx, req.(*UpdateParticipantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ParticipantService_DeleteParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteParticipantRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ParticipantServiceServer).DeleteParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.ParticipantService/DeleteParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ParticipantServiceServer).DeleteParticipant(ctx, req.(*DeleteParticipantRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ParticipantService_ServiceDesc is the grpc.ServiceDesc for ParticipantService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ParticipantService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "freesplit.ParticipantService",
	HandlerType: (*ParticipantServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddParticipant",
			Handler:    _ParticipantService_AddParticipant_Handler,
		},
		{
			MethodName: "UpdateParticipant",
			Handler:    _ParticipantService_UpdateParticipant_Handler,
		},
		{
			MethodName: "DeleteParticipant",
			Handler:    _ParticipantService_DeleteParticipant_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/expense.proto",
}

// DebtServiceClient is the client API for DebtService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DebtServiceClient interface {
	GetDebts(ctx context.Context, in *GetDebtsRequest, opts ...grpc.CallOption) (*GetDebtsResponse, error)
	UpdateDebtPaidAmount(ctx context.Context, in *UpdateDebtPaidAmountRequest, opts ...grpc.CallOption) (*UpdateDebtPaidAmountResponse, error)
}

type debtServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDebtServiceClient(cc grpc.ClientConnInterface) DebtServiceClient {
	return &debtServiceClient{cc}
}

func (c *debtServiceClient) GetDebts(ctx context.Context, in *GetDebtsRequest, opts ...grpc.CallOption) (*GetDebtsResponse, error) {
	out := new(GetDebtsResponse)
	err := c.cc.Invoke(ctx, "/freesplit.DebtService/GetDebts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *debtServiceClient) UpdateDebtPaidAmount(ctx context.Context, in *UpdateDebtPaidAmountRequest, opts ...grpc.CallOption) (*UpdateDebtPaidAmountResponse, error) {
	out := new(UpdateDebtPaidAmountResponse)
	err := c.cc.Invoke(ctx, "/freesplit.DebtService/UpdateDebtPaidAmount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DebtServiceServer is the server API for DebtService service.
// All implementations must embed UnimplementedDebtServiceServer
// for forward compatibility
type DebtServiceServer interface {
	GetDebts(context.Context, *GetDebtsRequest) (*GetDebtsResponse, error)
	UpdateDebtPaidAmount(context.Context, *UpdateDebtPaidAmountRequest) (*UpdateDebtPaidAmountResponse, error)
	mustEmbedUnimplementedDebtServiceServer()
}

// UnimplementedDebtServiceServer must be embedded to have forward compatible implementations.
type UnimplementedDebtServiceServer struct {
}

func (UnimplementedDebtServiceServer) GetDebts(context.Context, *GetDebtsRequest) (*GetDebtsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDebts not implemented")
}
func (UnimplementedDebtServiceServer) UpdateDebtPaidAmount(context.Context, *UpdateDebtPaidAmountRequest) (*UpdateDebtPaidAmountResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDebtPaidAmount not implemented")
}
func (UnimplementedDebtServiceServer) mustEmbedUnimplementedDebtServiceServer() {}

// UnsafeDebtServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DebtServiceServer will
// result in compilation errors.
type UnsafeDebtServiceServer interface {
	mustEmbedUnimplementedDebtServiceServer()
}

func RegisterDebtServiceServer(s grpc.ServiceRegistrar, srv DebtServiceServer) {
	s.RegisterService(&DebtService_ServiceDesc, srv)
}

func _DebtService_GetDebts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDebtsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebtServiceServer).GetDebts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.DebtService/GetDebts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebtServiceServer).GetDebts(ctx, req.(*GetDebtsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DebtService_UpdateDebtPaidAmount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDebtPaidAmountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DebtServiceServer).UpdateDebtPaidAmount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/freesplit.DebtService/UpdateDebtPaidAmount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DebtServiceServer).UpdateDebtPaidAmount(ctx, req.(*UpdateDebtPaidAmountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DebtService_ServiceDesc is the grpc.ServiceDesc for DebtService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DebtService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "freesplit.DebtService",
	HandlerType: (*DebtServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetDebts",
			Handler:    _DebtService_GetDebts_Handler,
		},
		{
			MethodName: "UpdateDebtPaidAmount",
			Handler:    _DebtService_UpdateDebtPaidAmount_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/expense.proto",
}
